// SPDX-License-Identifier: EVVM-NONCOMMERCIAL-1.0
pragma solidity 0.8.30;

/**
 * @title TreasuryWithRealProofs
 * @notice Example test file showing how to test Treasury with real RISC Zero proofs
 * @dev This is an example file - rename to TreasuryWithRealProofs.t.sol and implement
 *      your actual zkVM program path and logic
 * 
 * To use this:
 * 1. Rename this file to TreasuryWithRealProofs.t.sol
 * 2. Update the ELF_PATH constant to point to your compiled zkVM program
 * 3. Implement your zkVM program that generates proofs for Amazon purchase verification
 * 4. Update the generatePurchaseProof() function to match your program's input/output format
 */

import {BaseTest} from "../helpers/BaseTest.sol";
import {RiscZeroTestHelper} from "../helpers/RiscZeroTestHelper.sol";
import {Treasury} from "@evvm/testnet-contracts/contracts/treasury/Treasury.sol";

contract TreasuryWithRealProofs is BaseTest, RiscZeroTestHelper {
    // Path to your compiled zkVM program ELF file
    // This should be relative to the project root
    string constant ELF_PATH = "target/riscv32im-risc0-zkvm-elf/release/your_program";
    
    // Your zkVM program's image ID (obtained after compiling)
    bytes32 constant YOUR_IMAGE_ID = bytes32(0); // TODO: Replace with actual image ID

    function test_SubmitPurchase_WithRealProof() public {
        // Step 1: Create a listing
        uint256 listingAmount = 100 * 10 ** 6;
        Treasury.Listing memory listing = Treasury.Listing({
            url: "https://www.amazon.com/gp/your-account/order-details/?orderID=111-1234567-8901234",
            amount: listingAmount,
            shopper: alice
        });

        vm.startPrank(alice);
        usdc.approve(address(treasury), listingAmount);
        treasury.list(listing);
        vm.stopPrank();

        bytes32 listingId = treasury.calculateId(listing);

        // Step 2: Generate a real ZK proof for the purchase
        // Your zkVM program should verify the Amazon purchase and extract relevant data
        bytes memory purchaseInput = abi.encode(
            listing.url,
            // Add other inputs your zkVM program needs
            // e.g., API response, timestamp, etc.
        );
        
        (bytes memory journal, bytes memory seal, bytes32 journalHash) = 
            generateProofWithHash(ELF_PATH, purchaseInput);

        // Step 3: Decode the journal to get the purchase data
        // The journal format should match what your zkVM program outputs
        (
            bytes32 notaryKeyFingerprint,
            string memory method,
            string memory url,
            uint256 timestamp,
            bytes32 queriesHash
        ) = abi.decode(journal, (bytes32, string, string, uint256, bytes32));

        // Step 4: Prepare purchase data
        bytes memory purchaseData = abi.encode(
            notaryKeyFingerprint,
            method,
            url,
            timestamp,
            queriesHash
        );

        // Verify the journal hash matches
        assertEq(sha256(purchaseData), journalHash);

        // Step 5: Submit the purchase with real proof
        uint256 merchantBalanceBefore = evvm.getBalance(merchant, address(usdc));
        uint256 aliceBalanceBefore = evvm.getBalance(alice, address(usdc));

        vm.prank(merchant);
        treasury.submitPurchase(listingId, purchaseData, seal);

        // Step 6: Verify balances changed
        assertEq(evvm.getBalance(alice, address(usdc)), aliceBalanceBefore - listingAmount);
        assertEq(evvm.getBalance(merchant, address(usdc)), merchantBalanceBefore + listingAmount);

        // Verify listing was deleted
        (, , address shopper) = treasury.fetchListing(listingId);
        assertEq(shopper, address(0));
    }

    /**
     * @notice Helper function to generate a proof for a purchase
     * @dev This should match your zkVM program's expected input format
     */
    function generatePurchaseProof(
        string memory amazonUrl,
        // Add other parameters your zkVM program needs
    ) internal returns (bytes memory purchaseData, bytes memory seal) {
        // Prepare input for your zkVM program
        bytes memory input = abi.encode(
            amazonUrl,
            // Add other inputs
        );

        // Generate proof
        (bytes memory journal, bytes memory sealGenerated) = generateProof(ELF_PATH, input);
        
        // Decode journal to get purchase data
        purchaseData = journal; // Or decode and re-encode based on your format
        
        return (purchaseData, sealGenerated);
    }
}

